# kctsb v5.0 架构重构设计文档

> **创建时间**: 2026-01-25 (Beijing Time, UTC+8)  
> **版本**: 5.0.0  
> **类型**: Major Architecture Refactor

---

## 1. 重构目标

### 1.1 核心目标

**彻底自包含架构**：移除所有外部依赖（NTL, HElib, GMP, gf2x），仅保留硬件加速和汇编优化。

**对标目标**：
- OpenSSL 3.6：通用加密算法性能基线
- Microsoft SEAL 4.1：同态加密性能基线
- GMssl 4.x：国密算法性能基线

**性能目标**：
- 单元测试单个算法 <100ms
- 完整编译 + 测试 <10s
- 超越 OpenSSL/SEAL/GMssl 性能基线

---

## 2. 依赖关系分析

### 2.1 当前依赖（v4.15.0）

| 依赖库 | 用途 | 集成方式 | 状态 |
|--------|------|----------|------|
| NTL 11.6.0 | 大整数运算、ECC/RSA | 源码集成 `src/math/bignum/` | ❌ 待移除 |
| HElib v2.3.0 | 功能加密参考 | 链接静态库 | ❌ 待移除 |
| GMP 6.3.0 | 多精度整数 | 链接静态库 | ⚠️ 转为参考源码 |
| gf2x 1.3.0 | 二进制多项式 | 链接静态库 | ⚠️ 转为参考源码 |
| OpenSSL 3.6.0 | Benchmark 参考 | 链接静态库 | ✅ 仅 benchmark 使用 |
| SEAL 4.1.2 | Benchmark 参考 | 链接静态库 | ✅ 仅 benchmark 使用 |

### 2.2 受影响模块

| 模块 | 当前依赖 | 迁移策略 |
|------|----------|----------|
| RSA | NTL (`ZZ`, `ZZ_p`) | GMP++ + 自实现模幂 |
| ECC | NTL (`ZZ_p`, `GF2X`) | GMP++ + 自实现域运算 |
| Lattice/PQC | NTL (`mat_ZZ_p`) | 自实现 NTT + 模运算 |
| FHE (BGV/BFV/CKKS) | NTL (`ZZ_pX`, RNS) | 已自包含（v4.12.0+） |
| PSI/PIR | 无 NTL 依赖 | 无需修改 |

---

## 3. 迁移策略

### 3.1 Phase 1: 移除 NTL（最高优先级）

**步骤**：

1. **删除 NTL 源码**：
   ```bash
   rm -rf deps/NTL-11.6.0/
   rm -rf thirdparty/include/NTL/
   rm -rf src/math/bignum/  # 完全删除 bignum 目录
   ```

2. **RSA/ECC 重构**：
   - 使用 `libgmp` C++ 接口（`gmpxx.h`, `mpz_class`）
   - 参考 OpenSSL 的 `bn_*.c` 实现模幂优化
   - 参考 `deps/gmp-6.3.0/` 源码实现汇编加速

3. **替换 `ZZ` 类型**：
   ```cpp
   // Before (NTL)
   #include <NTL/ZZ.h>
   NTL::ZZ n = NTL::conv<ZZ>("123456789");
   
   // After (GMP++)
   #include <gmpxx.h>
   mpz_class n("123456789");
   ```

4. **自实现模运算**：
   ```cpp
   namespace kctsb::math {
       class BigInt {  // Wrapper around mpz_class
           mpz_class value_;
       public:
           BigInt modpow(const BigInt& exp, const BigInt& mod) const;
           BigInt modinv(const BigInt& mod) const;
       };
   }
   ```

**风险**：
- RSA/ECC 性能可能下降 → **缓解**：使用 GMP 汇编优化
- API 不兼容 → **缓解**：封装统一 API

---

### 3.2 Phase 2: 移除 HElib

**步骤**：

1. **删除 HElib 引用**：
   ```bash
   rm -rf deps/helib/
   rm -rf thirdparty/include/helib/
   ```

2. **FHE 完全使用原生实现**：
   - BGV/BFV/CKKS 已自包含（v4.12.0+）
   - 删除 `#include <helib/*>` 的测试代码

3. **移除功能加密（FE）模块**（如果依赖 HElib）：
   - 或重构为自实现版本

**影响**：
- 功能加密暂时不可用 → **后续版本**手动实现

---

### 3.3 Phase 3: GMP/gf2x 转为参考源码

**目标**：不再链接 GMP/gf2x 静态库，仅参考源码实现核心算法。

**步骤**：

1. **保留 deps 源码用于参考**：
   ```bash
   deps/
   ├── gmp-6.3.0/        # 参考多精度算法
   ├── gf2x-1.3.0/       # 参考二进制多项式
   └── gmssl-4.x/        # 参考国密实现
   ```

2. **自实现大整数库**：
   ```cpp
   namespace kctsb::math {
       class BigUint {  // 256/512/1024-bit 固定大小
           alignas(32) uint64_t limbs_[16];  // AVX2 对齐
       public:
           BigUint operator+(const BigUint&) const;  // AVX2 加法
           BigUint operator*(const BigUint&) const;  // Karatsuba
           BigUint modpow(const BigUint& exp, const BigUint& mod) const;
       };
   }
   ```

3. **参考 GMP 汇编优化**：
   ```asm
   ; deps/gmp-6.3.0/mpn/x86_64/*.asm
   ; 复制关键路径：add_n, mul_1, submul_1
   ```

**优势**：
- 编译时间减少（无需构建 GMP）
- 可控的内存布局（SIMD 友好）
- 无 LGPL 许可证传染

---

### 3.4 Phase 4: SM2 参考 GMssl 实现

**步骤**：

1. **下载 GMssl 源码**：
   ```bash
   cd deps/
   git clone --depth 1 https://github.com/guanzhi/GmSSL.git gmssl
   ```

2. **参考关键文件**：
   ```
   deps/gmssl/
   ├── src/sm2_sign.c    # SM2 签名
   ├── src/sm2_key.c     # SM2 密钥生成
   ├── src/sm3.c         # SM3 哈希
   └── src/sm4.c         # SM4 分组密码
   ```

3. **重构为 C++ + 硬件加速**：
   ```cpp
   // src/crypto/sm/sm2.cpp
   namespace kctsb::sm {
       class SM2 {
           // 参考 GMssl 逻辑，但使用：
           // - 自实现 ECC 点运算（已有 src/crypto/ecc/）
           // - AVX2 加速域运算
       };
   }
   ```

4. **Benchmark 对比**：
   ```cpp
   // benchmarks/sm2_benchmark.cpp
   void benchmark_sm2_sign() {
       // 硬编码 GMssl 基线：1234.5 ops/s
       auto kctsb_ops = measure_kctsb_sm2();
       report_speedup(kctsb_ops, 1234.5);
   }
   ```

---

### 3.5 Phase 5: Benchmark 硬编码基线数据

**目标**：移除运行时三方库依赖，仅对比硬编码数据。

**步骤**：

1. **一次性获取基线数据**：
   ```powershell
   # 临时链接 OpenSSL/SEAL/GMssl
   cmake -B build-baseline -DKCTSB_ENABLE_BASELINE_CAPTURE=ON
   .\build-baseline\bin\capture_baselines.exe > baselines.json
   ```

2. **硬编码到 benchmark 代码**：
   ```cpp
   // benchmarks/baseline_data.h
   namespace kctsb::baseline {
       constexpr double OPENSSL_AES_GCM_MBPS = 1234.5;
       constexpr double SEAL_BGV_KEYGEN_MS = 12.5;
       constexpr double GMSSL_SM2_SIGN_OPS = 3456.7;
   }
   ```

3. **Benchmark 仅运行 kctsb**：
   ```cpp
   auto kctsb_result = measure_aes_gcm();
   auto speedup = kctsb_result / baseline::OPENSSL_AES_GCM_MBPS;
   printf("AES-GCM: %.2fx vs OpenSSL\n", speedup);
   ```

**优势**：
- 编译时间 <3s（无需编译三方库）
- 无运行时依赖
- 对比结果稳定可复现

---

### 3.6 Phase 6: 自包含框架（参考 OpenSSL 3.6）

**目标**：运行时自动检测硬件能力，选择最优加速路径。

**参考 OpenSSL 实现**：
```c
// deps/openssl-3.6.0/crypto/cpuid.c
unsigned long OPENSSL_ia32cap_P[4];

void OPENSSL_cpuid_setup(void) {
    #ifdef __x86_64__
    __asm__ ("cpuid" : "=a"(cap[0]), "=b"(cap[1]), ...);
    #endif
}
```

**kctsb 实现**：
```cpp
// src/core/cpu_features.cpp
namespace kctsb::cpu {
    struct Features {
        bool aes_ni;
        bool avx2;
        bool avx512f;
        bool sha_ni;
    };
    
    Features detect_features() {
        Features f{};
        #ifdef __x86_64__
        uint32_t eax, ebx, ecx, edx;
        __cpuid(1, eax, ebx, ecx, edx);
        f.aes_ni = (ecx & (1 << 25)) != 0;
        f.avx2   = (ebx & (1 << 5)) != 0;
        #endif
        return f;
    }
    
    inline static Features g_features = detect_features();
}

// 使用示例
void aes_encrypt(const uint8_t* in, uint8_t* out) {
    if (cpu::g_features.aes_ni) {
        aes_encrypt_aesni(in, out);  // 快速路径
    } else {
        aes_encrypt_portable(in, out);  // 后备路径
    }
}
```

---

## 4. 性能优化策略

### 4.1 单元测试优化 (<100ms)

**策略**：

1. **减少测试向量**：
   ```cpp
   // Before: 100 iterations
   for (int i = 0; i < 100; i++) {
       test_aes_encrypt(key, iv, plaintext);
   }
   
   // After: 3 iterations (足够验证正确性)
   for (int i = 0; i < 3; i++) {
       test_aes_encrypt(key, iv, plaintext);
   }
   ```

2. **并行测试执行**：
   ```cmake
   enable_testing()
   add_test(NAME test_aes COMMAND test_aes)
   set_tests_properties(test_aes PROPERTIES PARALLEL_LEVEL 8)
   ```

3. **禁用性能测试**：
   ```cpp
   #ifndef KCTSB_ENABLE_PERF_TESTS
   TEST(AES, Performance) {
       GTEST_SKIP() << "Performance test disabled";
   }
   #endif
   ```

### 4.2 编译优化 (<10s)

**策略**：

1. **Ninja + 并行编译**：
   ```powershell
   cmake -G Ninja -DCMAKE_BUILD_PARALLEL_LEVEL=8
   ```

2. **预编译头（PCH）**：
   ```cmake
   target_precompile_headers(kctsb PRIVATE
       <cstdint>
       <cstring>
       <array>
       <vector>
   )
   ```

3. **Unity Build（可选）**：
   ```cmake
   set(CMAKE_UNITY_BUILD ON)
   set(CMAKE_UNITY_BUILD_BATCH_SIZE 16)
   ```

4. **默认禁用 Benchmark**：
   ```cmake
   option(KCTSB_BUILD_BENCHMARKS "Build benchmarks" OFF)
   ```

---

## 5. 代码组织

### 5.1 目录结构（v5.0）

```
kctsb/
├── include/kctsb/
│   ├── kctsb_api.h           # 唯一公共 API
│   └── core/
│       ├── cpu_features.h    # CPU 特性检测
│       └── bigint.h          # 自实现大整数
│
├── src/
│   ├── core/
│   │   ├── cpu_features.cpp  # CPUID 检测
│   │   └── bigint.cpp        # 大整数运算
│   ├── crypto/
│   │   ├── aes/              # AES-GCM (AES-NI 优化)
│   │   ├── sm/               # SM2/SM3/SM4 (参考 GMssl)
│   │   ├── ecc/              # ECC (自实现)
│   │   └── rsa/              # RSA (自实现)
│   ├── advanced/
│   │   ├── fhe/              # BGV/BFV/CKKS (已自包含)
│   │   └── psi/              # PSI/PIR
│   └── simd/
│       ├── aes_aesni.cpp     # AES-NI 实现
│       ├── sha256_shani.cpp  # SHA-NI 实现
│       └── ntt_avx2.cpp      # AVX2 NTT
│
├── deps/                      # 仅参考源码
│   ├── gmp-6.3.0/
│   ├── gf2x-1.3.0/
│   ├── gmssl/
│   └── openssl-3.6.0/
│
├── benchmarks/
│   ├── baseline_data.h       # 硬编码基线
│   └── benchmark_main.cpp    # 仅运行 kctsb
│
└── tests/
    └── unit/                  # 快速测试 (<100ms)
```

### 5.2 编译选项

```cmake
# CMakeLists.txt (v5.0)
cmake_minimum_required(VERSION 3.20)
project(kctsb VERSION 5.0.0)

set(CMAKE_CXX_STANDARD 17)

# 默认选项
option(KCTSB_BUILD_CLI "Build CLI tool" ON)
option(KCTSB_BUILD_TESTS "Build tests" ON)
option(KCTSB_BUILD_BENCHMARKS "Build benchmarks" ON)

# 硬件加速（默认启用）
option(KCTSB_ENABLE_AESNI "Enable AES-NI" ON)
option(KCTSB_ENABLE_AVX2 "Enable AVX2" ON)
option(KCTSB_ENABLE_SHANI "Enable SHA-NI" ON)

# 无外部依赖（v5.0）
# NO NTL, NO HElib, NO GMP linkage
```

---

## 6. 风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| RSA 性能下降 | 高 | 中 | 使用 GMP 汇编优化，参考 OpenSSL 实现 |
| 编译失败 | 高 | 低 | 逐步迁移，保留回滚分支 |
| 测试覆盖不足 | 中 | 中 | 增加边界测试，使用 NIST 向量 |
| 文档滞后 | 低 | 高 | 同步更新 README/AGENTS.md |

---

## 7. 成功标准

### 7.1 功能完整性

- ✅ 所有 crypto 算法正常工作（AES/SM2/RSA/ECC）
- ✅ FHE 所有 119 个测试通过
- ✅ PSI/PIR 正确性验证

### 7.2 性能目标

| 指标 | 目标 | 验证方式 |
|------|------|----------|
| 单元测试时间 | <100ms/算法 | `ctest --timeout 0.1` |
| 编译 + 测试 | <10s | `time (cmake --build && ctest)` |
| vs OpenSSL | ≥1.0x | Benchmark 对比 |
| vs SEAL | ≥1.0x | FHE Benchmark 对比 |
| vs GMssl | ≥1.0x | SM2 Benchmark 对比 |

### 7.3 代码质量

- ✅ 零外部依赖（除 benchmark）
- ✅ `src/` 目录完全自包含
- ✅ 无编译警告（`-Wall -Wextra`）
- ✅ Clang-Tidy 检查通过

---

## 8. 实施计划

| Phase | 任务 | 预计时间 | 负责人 |
|-------|------|----------|--------|
| 1 | 移除 NTL，重构 RSA/ECC | 2h | AI Agent |
| 2 | 移除 HElib | 30min | AI Agent |
| 3 | GMP/gf2x 转参考源码 | 1h | AI Agent |
| 4 | SM2 参考 GMssl 实现 | 1h | AI Agent |
| 5 | Benchmark 硬编码基线 | 30min | AI Agent |
| 6 | 自包含框架实现 | 1h | AI Agent |
| 7 | 性能优化 | 1h | AI Agent |
| 8 | CMake 重构 | 30min | AI Agent |
| 9 | 测试 + 修复 | 2h | AI Agent |
| 10 | 文档更新 + 发布 | 30min | AI Agent |

**总计**: ~10 小时

---

## 9. 回滚计划

如果重构失败，回滚到 v4.15.0：

```bash
git checkout tags/v4.15.0 -b rollback
cmake -B build -G Ninja
cmake --build build --parallel
```

---

**批准**: ✅ 开始执行  
**执行者**: GitHub Copilot (software-development-workflow skill)

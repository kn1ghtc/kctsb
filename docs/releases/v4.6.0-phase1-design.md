# kctsb v4.6.0 Phase 1 设计文档 - NTT + AVX2 + RNS 加速

> **版本**: v4.6.0  
> **日期**: 2026-01-22 (Beijing Time, UTC+8)  
> **状态**: 设计中

---

## 1. 目标概述

### 1.1 Phase 1 核心目标

| 目标 | 描述 | 验收标准 |
|------|------|----------|
| **NTT 实现** | O(n log n) 数论变换替代 O(n²) schoolbook | Multiply 性能提升 32x (n=8192) |
| **AVX2 加速** | 256-bit SIMD 向量化 NTT | 单核吞吐 >10 GB/s |
| **RNS 支持** | 残差数系统支持大模数 | q ≈ 2^200+ 支持 |
| **模数切换** | BGV 降噪操作 | 噪声预算正确下降 |
| **安全加固** | 消除全局状态依赖 | 100% 测试稳定 |

### 1.2 性能目标 (n=8192, 128-bit 安全)

| 操作 | 当前估计 | SEAL 4.1 | v4.6.0 目标 | 达成率 |
|------|----------|----------|-------------|--------|
| KeyGen | ~500 ms | 50 ms | < 80 ms | 62.5% |
| Encrypt | ~112 ms | 5 ms | < 8 ms | 62.5% |
| Add | ~0.3 ms | 0.1 ms | < 0.15 ms | 66.7% |
| Multiply | ~14600 ms | 10 ms | < 15 ms | 66.7% |
| Relin | ~500 ms | 8 ms | < 12 ms | 66.7% |

---

## 2. 架构设计

### 2.1 模块结构

```
src/advanced/fe/
├── common/                    # 共享组件 (新增)
│   ├── ntt.cpp               # NTT 核心实现
│   ├── ntt_avx2.cpp          # AVX2 加速版本
│   ├── rns.cpp               # RNS 基转换
│   └── poly_arith.cpp        # 多项式算术
│
├── bgv/                       # BGV 方案 (重构)
│   ├── bgv_context.cpp       # 上下文管理 (重构)
│   ├── bgv_context.hpp       # 公共接口
│   ├── bgv_keys.cpp          # 密钥管理 (新增)
│   ├── bgv_encrypt.cpp       # 加密/解密 (拆分)
│   ├── bgv_eval.cpp          # 同态运算 (拆分)
│   └── bgv_modswitch.cpp     # 模数切换 (新增)
│
└── benchmark/
    └── bench_bgv_vs_seal.cpp  # SEAL 对比基准
```

### 2.2 核心数据结构

```cpp
namespace kctsb::fhe {

/**
 * @brief NTT 预计算表
 * @note 线程安全，每个模数一个实例
 */
class NTTTable {
public:
    NTTTable(size_t n, uint64_t q);
    
    // 正向/逆向 NTT (原地操作)
    void forward(uint64_t* data) const;
    void inverse(uint64_t* data) const;
    
    // AVX2 加速版本
    void forward_avx2(uint64_t* data) const;
    void inverse_avx2(uint64_t* data) const;
    
private:
    size_t n_;
    uint64_t q_;
    std::vector<uint64_t> roots_;      // 单位根 ω^i
    std::vector<uint64_t> inv_roots_;  // 逆单位根
    uint64_t n_inv_;                   // n 的模逆
};

/**
 * @brief RNS 多项式表示
 * @note 每个素数模数一个系数向量
 */
class RNSPoly {
public:
    RNSPoly(size_t n, const std::vector<uint64_t>& moduli);
    
    // NTT 形式转换
    void to_ntt();
    void from_ntt();
    bool is_ntt() const;
    
    // RNS 层访问
    uint64_t* operator[](size_t level);
    const uint64_t* operator[](size_t level) const;
    
    // 算术运算 (元素级)
    RNSPoly& operator+=(const RNSPoly& other);
    RNSPoly& operator*=(const RNSPoly& other);  // NTT 形式下
    
private:
    size_t n_;
    std::vector<uint64_t> moduli_;
    std::vector<std::vector<uint64_t>> coeffs_;  // [level][coeff_idx]
    bool is_ntt_;
};

/**
 * @brief BGV 上下文 (线程安全重构)
 */
class BGVContext {
public:
    explicit BGVContext(const BGVParams& params);
    
    // 密钥操作
    BGVSecretKey generate_secret_key();
    BGVPublicKey generate_public_key(const BGVSecretKey& sk);
    BGVRelinKey generate_relin_key(const BGVSecretKey& sk);
    
    // 加密/解密
    BGVCiphertext encrypt(const BGVPublicKey& pk, const BGVPlaintext& pt);
    BGVPlaintext decrypt(const BGVSecretKey& sk, const BGVCiphertext& ct);
    
    // 模数切换
    void mod_switch_to_next(BGVCiphertext& ct);
    
    // 参数访问
    const BGVParams& params() const { return params_; }
    const NTTTable& ntt_table(size_t level) const;
    
private:
    BGVParams params_;
    std::vector<std::unique_ptr<NTTTable>> ntt_tables_;  // 每层一个
    // 无全局状态依赖
};

}  // namespace kctsb::fhe
```

---

## 3. NTT 实现

### 3.1 Cooley-Tukey 蝴蝶算法

```cpp
/**
 * @brief 正向 NTT (Cooley-Tukey, decimation-in-time)
 * @param data 输入/输出数组 (n 个元素)
 * 
 * 复杂度: O(n log n)
 * 原地操作，无额外内存分配
 */
void NTTTable::forward(uint64_t* data) const {
    size_t t = n_;
    for (size_t m = 1; m < n_; m <<= 1) {
        t >>= 1;
        for (size_t i = 0; i < m; ++i) {
            size_t j1 = 2 * i * t;
            size_t j2 = j1 + t;
            uint64_t W = roots_[m + i];  // 单位根
            
            for (size_t j = j1; j < j2; ++j) {
                uint64_t u = data[j];
                uint64_t v = mul_mod(data[j + t], W, q_);
                
                data[j] = add_mod(u, v, q_);
                data[j + t] = sub_mod(u, v, q_);
            }
        }
    }
}
```

### 3.2 AVX2 向量化

```cpp
/**
 * @brief AVX2 加速 NTT
 * @note 4 路并行，使用 256-bit 寄存器
 */
void NTTTable::forward_avx2(uint64_t* data) const {
#ifdef __AVX2__
    // Barrett reduction 预计算
    __m256i q_vec = _mm256_set1_epi64x(q_);
    __m256i q_inv = _mm256_set1_epi64x(barrett_factor_);
    
    size_t t = n_;
    for (size_t m = 1; m < n_; m <<= 1) {
        t >>= 1;
        
        if (t >= 4) {  // 向量化路径
            for (size_t i = 0; i < m; ++i) {
                __m256i W = _mm256_set1_epi64x(roots_[m + i]);
                
                for (size_t j = 2 * i * t; j < 2 * i * t + t; j += 4) {
                    __m256i u = _mm256_loadu_si256((__m256i*)(data + j));
                    __m256i v = _mm256_loadu_si256((__m256i*)(data + j + t));
                    
                    // v = v * W mod q (使用 Barrett reduction)
                    v = barrett_mul_avx2(v, W, q_vec, q_inv);
                    
                    // 蝴蝶运算
                    __m256i sum = add_mod_avx2(u, v, q_vec);
                    __m256i diff = sub_mod_avx2(u, v, q_vec);
                    
                    _mm256_storeu_si256((__m256i*)(data + j), sum);
                    _mm256_storeu_si256((__m256i*)(data + j + t), diff);
                }
            }
        } else {
            // 标量路径处理小 t
            forward_scalar_tail(data, m, t);
        }
    }
#else
    forward(data);  // 回退到标量版本
#endif
}
```

### 3.3 模乘优化

```cpp
/**
 * @brief Barrett reduction 模乘
 * @note 避免除法，使用预计算因子
 */
inline uint64_t mul_mod_barrett(uint64_t a, uint64_t b, 
                                 uint64_t q, uint64_t mu) {
    __uint128_t ab = (__uint128_t)a * b;
    uint64_t lo = (uint64_t)ab;
    uint64_t hi = (uint64_t)(ab >> 64);
    
    // q' = floor((hi * mu) / 2^64)
    uint64_t q_prime = ((__uint128_t)hi * mu) >> 64;
    
    // r = ab - q' * q
    uint64_t r = lo - q_prime * q;
    
    // 修正：r 可能需要额外减一次 q
    if (r >= q) r -= q;
    
    return r;
}
```

---

## 4. RNS 基转换

### 4.1 CRT 重构

```cpp
/**
 * @brief RNS → 整数 (中国剩余定理)
 * @param residues 各模数下的残差
 * @param moduli 模数列表
 * @return 完整整数值
 */
ZZ rns_to_integer(const std::vector<uint64_t>& residues,
                  const std::vector<uint64_t>& moduli) {
    ZZ result = conv<ZZ>(0);
    ZZ M = conv<ZZ>(1);
    
    for (auto q : moduli) M *= q;
    
    for (size_t i = 0; i < moduli.size(); ++i) {
        ZZ Mi = M / moduli[i];
        ZZ Mi_inv = InvMod(Mi % moduli[i], conv<ZZ>(moduli[i]));
        result += conv<ZZ>(residues[i]) * Mi * Mi_inv;
    }
    
    return result % M;
}
```

### 4.2 快速基转换 (BEHZ)

```cpp
/**
 * @brief BEHZ 快速基转换
 * @note 用于 BFV/BGV 的缩放除法
 */
class BEHZConverter {
public:
    BEHZConverter(const std::vector<uint64_t>& base_q,
                  const std::vector<uint64_t>& base_Bsk);
    
    // Q → Bsk 转换
    void fast_convert_q_to_bsk(const RNSPoly& in, RNSPoly& out);
    
    // Bsk → Q 转换
    void fast_convert_bsk_to_q(const RNSPoly& in, RNSPoly& out);
    
private:
    std::vector<uint64_t> q_hat_inv_;   // Q̂_i^{-1} mod q_i
    std::vector<uint64_t> q_hat_mod_bsk_; // Q̂_i mod B_j
    // ... 预计算表
};
```

---

## 5. 安全加固

### 5.1 消除全局状态

**原问题**: NTL `ZZ_p::init()` 使用全局模数

**解决方案**: 使用 `uint64_t` 原生类型存储 RNS 系数，避免 NTL ZZ_p

```cpp
// 旧实现 (危险)
class RingElement {
    ZZ_pX poly_;  // 依赖全局 ZZ_p 模数
};

// 新实现 (安全)
class RNSPoly {
    std::vector<std::vector<uint64_t>> coeffs_;  // 模数无关
    std::vector<uint64_t> moduli_;               // 显式存储模数
};
```

### 5.2 上下文版本控制

```cpp
class BGVContext {
private:
    uint64_t version_;  // 每次参数变化时递增
    
public:
    // 密钥绑定上下文版本
    BGVSecretKey generate_secret_key() {
        BGVSecretKey sk;
        sk.context_version_ = version_;
        // ...
        return sk;
    }
    
    // 操作时验证版本
    BGVCiphertext encrypt(const BGVPublicKey& pk, ...) {
        if (pk.context_version_ != version_) {
            throw std::runtime_error("Key context mismatch");
        }
        // ...
    }
};
```

### 5.3 深度链式操作测试

```cpp
TEST(BGVTest, DeepChainedOperations) {
    auto ctx = BGVContext(StandardParams::SECURITY_128());
    auto sk = ctx.generate_secret_key();
    auto pk = ctx.generate_public_key(sk);
    auto rk = ctx.generate_relin_key(sk);
    
    // 10 层深度链式乘法
    auto ct = ctx.encrypt(pk, encoder.encode(2));
    for (int i = 0; i < 10; ++i) {
        ct = evaluator.square(ct);
        ct = evaluator.relinearize(ct, rk);
        ctx.mod_switch_to_next(ct);
        
        // 验证可解密
        auto pt = ctx.decrypt(sk, ct);
        ASSERT_EQ(encoder.decode(pt), power(2, 1 << (i + 1)));
    }
}
```

---

## 6. 验收标准

### 6.1 功能验收

| 测试项 | 验收标准 |
|--------|----------|
| NTT 正确性 | 与 schoolbook 结果一致 |
| AVX2 正确性 | 与标量版本结果一致 |
| RNS 正确性 | CRT 重构精确 |
| 模数切换 | 噪声预算下降符合预期 |
| 安全性 | 无全局状态泄露 |
| 测试稳定性 | 100 次运行 100% 通过 |

### 6.2 性能验收

| 指标 | 目标 |
|------|------|
| NTT (n=8192) | < 0.5 ms |
| Multiply (n=8192) | < 15 ms |
| SEAL 对比 | ≥ 80% 性能 |

### 6.3 测试用例

1. **NIST 测试向量**: AES-256 在 FHE 下正确计算
2. **深度链式操作**: 10+ 层乘法正确解密
3. **噪声预算**: 与理论值偏差 < 5%
4. **边界测试**: n=256, 4096, 8192, 16384

---

## 7. 实施计划

| 阶段 | 任务 | 预计时间 |
|------|------|----------|
| 7.1 | NTT 核心实现 | 2h |
| 7.2 | AVX2 向量化 | 2h |
| 7.3 | RNS 基转换 | 2h |
| 7.4 | BGV 重构集成 | 3h |
| 7.5 | 模数切换 | 2h |
| 7.6 | SEAL benchmark | 1h |
| 7.7 | 测试与文档 | 2h |

**总计**: ~14 小时

---

*文档结束*

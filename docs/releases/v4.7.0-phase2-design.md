# kctsb v4.7.0 Phase 2 设计文档 - BFV 实现与性能优化

> **版本**: v4.7.0 Phase 2  
> **日期**: 2026-01-22 (Beijing Time, UTC+8)  
> **状态**: ✅ 已完成

---

## 0. Phase 2 完成状态

### 0.1 Phase 2 完成项 ✅

| 组件 | 状态 | 测试 | 备注 |
|------|------|------|------|
| **BFV 头文件** | ✅ 完成 | - | `include/kctsb/advanced/fe/bfv/bfv.hpp` |
| **BFV 实现** | ✅ 完成 | 25/25 | `src/advanced/fe/bfv/bfv_context.cpp` |
| **BGV 复用** | ✅ 完成 | - | SecretKey/PublicKey/Ciphertext 类型复用 |
| **BFVEncoder** | ✅ 完成 | 4/4 | 直接编码（无 Δ-scaling，复用 BGV 解密） |
| **BFVContext** | ✅ 完成 | 3/3 | 参数管理、密钥生成 |
| **BFVEvaluator** | ✅ 完成 | 6/6 | 同态运算 |
| **深度测试** | ✅ 完成 | 2/2 | 支持 2-3 层乘法 |
| **集成测试** | ✅ 完成 | 346/346 | 所有测试通过 |

### 0.2 BFV 实现架构

```
BFV 复用 BGV 基础设施:
┌─────────────────────────────────────────────┐
│ BFV API Layer (bfv.hpp)                     │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────┐ │
│ │ BFVParams   │ │ BFVContext  │ │BFVEncoder│ │
│ │ BFVEvaluator│ │ StandardParams         │ │
│ └─────────────┘ └─────────────┘ └─────────┘ │
└─────────────────────────────────────────────┘
                      │
                      ▼ 委托
┌─────────────────────────────────────────────┐
│ BGV Core Layer (bgv.hpp)                    │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────┐ │
│ │BGVSecretKey │ │BGVPublicKey │ │BGVCipher│ │
│ │BGVContext   │ │BGVEvaluator │ │BGVPlain │ │
│ └─────────────┘ └─────────────┘ └─────────┘ │
└─────────────────────────────────────────────┘
```

### 0.3 Phase 1 BGV Benchmark (NTT 启用)

**测试环境**: Windows 11, AMD Ryzen, MinGW-w64 GCC 13, Release + LTO

| 操作 | kctsb (ms) | SEAL 4.1 参考 (ms) | 差距倍数 | 瓶颈分析 |
|------|-----------|-------------------|---------|---------|
| KeyGen (SK+PK) | 4,209 | ~50 | **84x** | NTL ZZ 运算慢 |
| Encrypt | 8,585 | ~5 | **1717x** | NTL 采样 + 多项式运算 |
| Decrypt | 4,288 | ~2 | **2144x** | ZZ_pX 模运算 |
| Add | 1.24 | 0.1 | **12x** | 可接受 |
| **Multiply** | **2,893** | ~10 | **289x** | CRT 重构开销大 |
| Multiply+Relin | 25,487 | ~18 | **1416x** | Relin 密钥操作慢 |

**NTT 加速效果**: Multiply 从 ~11,000ms 降至 ~2,893ms，提升 **3.8x**

### 0.3 BFV Benchmark 结果 (2026-01-22)

**测试环境**: Windows 11, AMD Ryzen, MinGW-w64 GCC 13, Release + LTO

#### SECURITY_128 (n=8192, 128-bit security)

| 操作 | kctsb BFV (ms) | SEAL 4.1 参考 (ms) | 差距倍数 |
|------|---------------|-------------------|---------|
| KeyGen (SK+PK) | 1,731 | ~50 | **35x** |
| Relin Key Gen | 10,081 | ~10 | **1000x** |
| Encrypt | 8,501 | ~5 | **1700x** |
| Decrypt | 4,289 | ~2 | **2144x** |
| Add | 2.01 | 0.1 | **20x** |
| **Multiply** | **3,295** | ~10 | **329x** |
| Multiply+Relin | 25,642 | ~18 | **1425x** |

#### BFV vs BGV 对比 (TOY_PARAMS n=256)

| 操作 | BFV (ms) | BGV (ms) | 差异 |
|------|----------|----------|------|
| Encrypt | 3.29 | 3.40 | -3.2% |
| Decrypt | 1.7 | 1.6 | +2.5% |
| Add | 0.01 | 0.01 | +20.4% |
| Multiply | 5.8 | 7.1 | **-18.3%** |

**结论**: BFV 与 BGV 性能基本持平（差异 < 20%），因为 BFV 完全复用 BGV 基础设施。

### 0.4 性能差距根因分析

| 瓶颈 | 根因 | 影响操作 | 优化策略 |
|------|------|----------|----------|
| **NTL ZZ 开销** | 大整数运算使用 GMP，效率低于 native uint64_t | KeyGen, Encrypt, Decrypt | RNSPoly 原生表示 |
| **CRT 重构** | `crt_reconstruct_poly` 对每个系数调用大整数运算 | Multiply | 延迟 CRT，NTT 域计算 |
| **Relin 密钥** | 每次 relin 计算完整张量积 | Multiply+Relin | 密钥切换优化 |
| **随机采样** | NTL 随机数，非批量 | Encrypt | 批量 CSPRNG |

**关键洞察**: SEAL 使用 native `uint64_t` + RNS 表示，避免大整数；kctsb 仍依赖 NTL `ZZ_pX`。

---

## 1. Phase 2 目标

### 1.1 核心目标

| 目标 | 描述 | 验收标准 | 优先级 |
|------|------|----------|--------|
| **BFV 实现** | Scale-invariant 编码方案 | 通过 NIST 测试向量 | P0 |
| **正确性验证** | BFV 加法/乘法/重缩放 | 100% 测试通过 | P0 |
| **Benchmark** | BFV vs BGV vs SEAL 对比 | 性能数据 | P1 |
| **统一 API** | BGV/BFV 共享接口 | 复用率 > 80% | P2 |

### 1.2 Phase 2 不做的事情 (留给 Phase 3)

- 性能优化至接近 SEAL 水平（需要架构重构）
- CKKS 近似计算
- RNSPoly 原生实现（需要替换 NTL）

### 1.3 性能目标 (Phase 2 现实目标)

| 操作 | 当前 BGV (ms) | Phase 2 BFV 目标 (ms) | SEAL 参考 (ms) |
|------|-------------|---------------------|---------------|
| Multiply | 2,893 | < 3,000 | ~10 |
| Encrypt | 8,585 | < 9,000 | ~5 |
| Add | 1.24 | < 2 | ~0.1 |

**说明**: Phase 2 专注正确性，性能优化留给 Phase 3 RNSPoly 重构。

---

## 2. 技术方案

### 2.1 BFV vs BGV 核心差异

| 特性 | BGV | BFV |
|------|-----|-----|
| **编码** | m → m (直接) | m → Δ·m (缩放), Δ = ⌊q/t⌋ |
| **乘法后处理** | 模数切换 (mod switch) | 重缩放 (rescale) ÷ Δ |
| **噪声模型** | 线性增长 | 恒定增长 (scale-invariant) |
| **优势场景** | 浅层电路 | 深层计算 |
| **SEAL 实现** | N/A (仅 BFV+CKKS) | 主要方案 |

### 2.2 BFV 数学定义

**编码 (Encode)**:
$$\text{encode}(m) = \Delta \cdot m \mod q, \quad \Delta = \lfloor q/t \rfloor$$

**解码 (Decode)**:
$$\text{decode}(p) = \lfloor p / \Delta \rceil \mod t$$

**加密 (Encrypt)**:
$$ct = (c_0, c_1) = (\Delta \cdot m + e + a \cdot s, a + e')$$

**解密 (Decrypt)**:
$$m' = \lfloor (c_0 - c_1 \cdot s) / \Delta \rceil \mod t$$

**乘法 + 重缩放 (Multiply + Rescale)**:
$$ct_{mult} = \text{tensor}(ct_1, ct_2)$$
$$ct_{rescaled} = \lfloor ct_{mult} / \Delta \rceil$$

### 2.3 代码复用策略

```
BFV 复用 BGV 组件:
├── BGVContext        → BFVContext (参数差异)
├── BGVSecretKey      → 复用 100%
├── BGVPublicKey      → 复用 100%
├── BGVRelinKey       → 复用 100%
├── BGVCiphertext     → 复用 100%
├── RingElement       → 复用 100%
├── BGVEvaluator      → BFVEvaluator (乘法/重缩放差异)
├── NTT/RNS 层        → 复用 100%
└── BGVEncoder        → BFVEncoder (编码/解码差异)
```

### 2.4 BFV 实现架构

```
include/kctsb/advanced/fe/bfv/
├── bfv.hpp               # 公共 API (类似 bgv.hpp)
├── bfv_encoder.hpp       # BFV 编码器 (Δ 缩放)
└── bfv_evaluator.hpp     # BFV 运算器 (rescale)

src/advanced/fe/bfv/
├── bfv_context.cpp       # BFV 上下文 (复用 BGV 大部分)
├── bfv_encoder.cpp       # 编码: m → Δm, 解码: p → ⌊p/Δ⌋
├── bfv_evaluator.cpp     # 乘法后 rescale 而非 mod switch
└── bfv_keygen.cpp        # 复用 BGV (可直接 include)

tests/unit/fhe/
└── test_bfv.cpp          # BFV 测试套件
```

---

## 3. 实施计划

### 3.1 阶段任务

| 任务 | 预计时间 | 依赖 | 交付物 |
|------|----------|------|--------|
| 3.1 BFV 头文件设计 | 1h | - | bfv.hpp |
| 3.2 BFVEncoder 实现 | 2h | 3.1 | bfv_encoder.cpp |
| 3.3 BFVContext 实现 | 1h | 3.1 | bfv_context.cpp |
| 3.4 BFVEvaluator.rescale | 2h | 3.3 | bfv_evaluator.cpp |
| 3.5 BFV 乘法集成 | 2h | 3.4 | multiply() 使用 rescale |
| 3.6 BFV 测试套件 | 2h | 3.5 | test_bfv.cpp |
| 3.7 BFV Benchmark | 1h | 3.6 | benchmark 数据 |
| 3.8 文档更新 | 1h | 3.7 | README, release notes |

**总计**: ~12 小时

### 3.2 详细文件变更

**新增文件**:
```
include/kctsb/advanced/fe/bfv/bfv.hpp           # 200 行
include/kctsb/advanced/fe/bfv/bfv_encoder.hpp   # 80 行
include/kctsb/advanced/fe/bfv/bfv_evaluator.hpp # 100 行
src/advanced/fe/bfv/bfv_context.cpp             # 150 行
src/advanced/fe/bfv/bfv_encoder.cpp             # 100 行
src/advanced/fe/bfv/bfv_evaluator.cpp           # 200 行
tests/unit/fhe/test_bfv.cpp                     # 400 行
```

**修改文件**:
```
CMakeLists.txt                                  # 添加 BFV 源文件
tests/CMakeLists.txt                            # 添加 test_bfv target
```

---

## 4. 代码设计

### 4.1 BFV 公共接口 (bfv.hpp)

```cpp
#pragma once

#include "kctsb/advanced/fe/bgv/bgv.hpp"  // 复用 BGV 基础组件

namespace kctsb::fhe::bfv {

// 类型别名 - 复用 BGV
using SecretKey = bgv::SecretKey;
using PublicKey = bgv::PublicKey;
using RelinKey = bgv::RelinKey;
using Ciphertext = bgv::BGVCiphertext;
using Plaintext = bgv::BGVPlaintext;
using RingElement = bgv::RingElement;

/**
 * @brief BFV 参数配置
 * @note 与 BGV 参数结构相同，但语义不同 (scale-invariant)
 */
struct BFVParams {
    size_t n;           // 多项式度 (2^k)
    uint64_t t;         // 明文模数
    NTL::ZZ q;          // 密文模数
    std::vector<uint64_t> primes;  // RNS 分解
    size_t L;           // 模数链深度
    
    // BFV 特有
    NTL::ZZ delta() const { return q / NTL::ZZ(t); }  // Δ = ⌊q/t⌋
    
    static BFVParams create_standard(size_t ring_degree, uint64_t plain_modulus);
};

/**
 * @brief BFV 上下文 (密钥和参数管理)
 */
class BFVContext {
public:
    explicit BFVContext(const BFVParams& params);
    
    // 密钥生成 (委托给 BGV)
    SecretKey generate_secret_key();
    PublicKey generate_public_key(const SecretKey& sk);
    RelinKey generate_relin_key(const SecretKey& sk);
    
    // 加密/解密 (BFV 编码)
    Ciphertext encrypt(const PublicKey& pk, const Plaintext& pt);
    Plaintext decrypt(const SecretKey& sk, const Ciphertext& ct);
    
    const BFVParams& params() const { return params_; }
    
private:
    BFVParams params_;
    bgv::BGVContext bgv_ctx_;  // 内部复用 BGV
};

/**
 * @brief BFV 编码器 (scale by Δ)
 */
class BFVEncoder {
public:
    explicit BFVEncoder(const BFVContext& ctx);
    
    // 编码: m → Δ·m mod q
    Plaintext encode(int64_t value);
    Plaintext encode_batch(const std::vector<int64_t>& values);
    
    // 解码: p → round(p / Δ) mod t
    int64_t decode(const Plaintext& pt);
    std::vector<int64_t> decode_batch(const Plaintext& pt);
    
private:
    const BFVContext& ctx_;
    NTL::ZZ delta_;
};

/**
 * @brief BFV 同态运算器
 */
class BFVEvaluator {
public:
    explicit BFVEvaluator(const BFVContext& ctx);
    
    // 加法 (与 BGV 相同)
    Ciphertext add(const Ciphertext& ct1, const Ciphertext& ct2);
    Ciphertext add_plain(const Ciphertext& ct, const Plaintext& pt);
    
    // 乘法 (需要 rescale)
    Ciphertext multiply(const Ciphertext& ct1, const Ciphertext& ct2);
    Ciphertext multiply_plain(const Ciphertext& ct, const Plaintext& pt);
    
    // BFV 核心: 重缩放
    Ciphertext rescale(const Ciphertext& ct);
    
    // 乘法 + 重线性化 + 重缩放
    Ciphertext multiply_relin_rescale(const Ciphertext& ct1, 
                                       const Ciphertext& ct2,
                                       const RelinKey& rk);
    
private:
    const BFVContext& ctx_;
    bgv::BGVEvaluator bgv_eval_;
};

}  // namespace kctsb::fhe::bfv
```

### 4.2 BFV 编码器核心实现

```cpp
// bfv_encoder.cpp

Plaintext BFVEncoder::encode(int64_t value) {
    // Δ = floor(q / t)
    ZZ delta = ctx_.params().delta();
    
    // 处理负数: value mod t 映射到 [0, t-1]
    int64_t t = conv<long>(ctx_.params().t);
    int64_t normalized = ((value % t) + t) % t;
    
    // scaled = Δ * normalized mod q
    ZZ scaled = (delta * ZZ(normalized)) % ctx_.params().q;
    
    Plaintext pt;
    SetCoeff(pt.data(), 0, conv<ZZ_p>(scaled));
    return pt;
}

int64_t BFVEncoder::decode(const Plaintext& pt) {
    ZZ coef = IsZero(coeff(pt.data(), 0)) ? ZZ(0) : rep(coeff(pt.data(), 0));
    ZZ delta = ctx_.params().delta();
    
    // round(coef / delta) mod t
    // round(x) = floor(x + 0.5) = floor((2x + delta) / (2*delta))
    ZZ rounded = (2 * coef + delta) / (2 * delta);
    
    return conv<long>(rounded % ZZ(ctx_.params().t));
}
```

### 4.3 BFV 重缩放实现

```cpp
// bfv_evaluator.cpp

Ciphertext BFVEvaluator::rescale(const Ciphertext& ct) {
    // BFV rescale: ct' = round(ct / Δ)
    // 这会将 scale Δ² 降回 Δ (乘法后)
    
    const auto& params = ctx_.params();
    ZZ delta = params.delta();
    ZZ q = params.q;
    
    Ciphertext result;
    
    for (size_t i = 0; i < ct.size(); i++) {
        RingElement re;
        const auto& poly = ct[i].poly();
        
        for (long j = 0; j <= deg(poly); j++) {
            ZZ coef = IsZero(coeff(poly, j)) ? ZZ(0) : rep(coeff(poly, j));
            
            // round(coef / delta) = floor((2*coef + delta) / (2*delta))
            ZZ rounded = (2 * coef + delta) / (2 * delta);
            
            // 确保结果在 [0, q/delta) 范围内
            ZZ new_q = q / delta;
            rounded = rounded % new_q;
            
            SetCoeff(re.poly(), j, conv<ZZ_p>(rounded));
        }
        
        result.push_back(re);
    }
    
    return result;
}

Ciphertext BFVEvaluator::multiply(const Ciphertext& ct1, const Ciphertext& ct2) {
    // 使用 BGV 的张量乘法
    Ciphertext product = bgv_eval_.multiply(ct1, ct2);
    
    // BFV 特有: 乘法后立即 rescale
    return rescale(product);
}
```

---

## 5. 验收标准

### 5.1 功能验收

| 测试项 | 验收标准 |
|--------|----------|
| BFV 编码/解码 | encode(m) → decode() = m (所有 t 范围内整数) |
| BFV 加密/解密 | encrypt(pt) → decrypt() = pt |
| BFV 加法 | ct1 + ct2 解密正确 |
| BFV 乘法 | ct1 * ct2 解密正确 (带 rescale) |
| BFV 深度计算 | 5 层乘法正确解密 |
| BFV 参数集 | TOY/128-bit 安全参数通过 |

### 5.2 测试矩阵

| 测试类别 | 测试数量 | 覆盖范围 |
|----------|----------|----------|
| BFVEncoderTest | 6 | encode/decode/batch |
| BFVContextTest | 4 | 参数/密钥生成 |
| BFVEncryptionTest | 5 | encrypt/decrypt |
| BFVOperationTest | 8 | add/multiply/rescale |
| BFVDepthTest | 3 | 多层乘法 |

**总计**: 26 个 BFV 测试用例

### 5.3 Benchmark 验收

| 指标 | 目标 | 验收 |
|------|------|------|
| BFV 测试通过率 | 100% | 必须 |
| BFV Multiply | < 3,000 ms | 期望 |
| BFV vs BGV 正确性 | 相同输入相同输出 | 必须 |

---

## 6. 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| rescale 精度损失 | 中 | 高 | 使用足够大的 Δ 和 q |
| 噪声增长过快 | 低 | 中 | 参考 SEAL 参数选择 |
| 与 BGV 接口冲突 | 低 | 低 | 使用独立命名空间 |

---

## 7. Phase 3 展望 (性能优化)

**目标**: 将性能差距从 ~100x 缩小到 ~5x

| 优化项 | 预期提升 | 复杂度 |
|--------|----------|--------|
| RNSPoly 原生实现 | 10-50x | 高 |
| 延迟 CRT 重构 | 2-5x | 中 |
| AVX2 密钥操作 | 2-3x | 中 |
| 批量随机采样 | 5-10x Encrypt | 低 |

---

*Phase 2 设计文档结束 - 等待实施*

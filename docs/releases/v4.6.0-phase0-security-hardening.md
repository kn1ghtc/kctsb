# v4.6.0-phase0-security-hardening.md

> **kctsb BGV Security Hardening Design Document**
> 
> Based on Chapter 6 lessons from `bgv_ntl_modulus_pollution.md`

## 1. 概述

本文档描述 BGV 安全加固的设计方案，针对 troubleshooting 文档第6章总结的教训进行系统性改进。

### 1.1 问题回顾

| 教训 | 问题描述 | 解决方案 |
|------|---------|---------|
| 6.1 全局状态危险 | NTL 的 ZZ_p 全局模数在多上下文场景下引入隐蔽 bug | 使用 ZZ_pBak/ZZ_pContext 保护，文档化依赖 |
| 6.2 测试覆盖不足 | 简单测试没有触发 bug，需要深度链式操作 | 添加 Power 测试、多级乘法测试 |
| 6.3 缓存未考虑上下文 | `sk.power(i)` 缓存假设上下文不变 | 添加上下文版本控制，变化时失效 |

### 1.2 目标

1. **零全局状态泄漏**：所有 BGV 操作在进入时保护、退出时恢复全局状态
2. **上下文版本控制**：每个 BGVContext 有唯一版本号，缓存绑定版本
3. **深度测试覆盖**：Power 测试、连续乘法测试、多上下文交叉测试

---

## 2. 设计方案

### 2.1 上下文版本控制

```cpp
class BGVContext {
public:
    // 上下文唯一版本号 (单调递增)
    uint64_t version() const { return version_; }
    
    // 检查缓存是否有效
    bool is_cache_valid(uint64_t cached_version) const {
        return cached_version == version_;
    }

private:
    static std::atomic<uint64_t> global_version_counter_;
    uint64_t version_;
};
```

### 2.2 缓存失效机制

```cpp
class BGVSecretKey {
public:
    const RingElement& power(size_t k, const BGVContext& ctx) const {
        // 检查缓存版本
        if (cached_context_version_ != ctx.version()) {
            invalidate_cache();
            cached_context_version_ = ctx.version();
        }
        
        // 设置正确的模数上下文
        ZZ_pBak bak;
        bak.save();
        ctx.set_modulus_context();
        
        // 计算或返回缓存
        return compute_power_internal(k);
    }
    
    void invalidate_cache() const {
        powers_.clear();
        cached_context_version_ = 0;
    }

private:
    mutable uint64_t cached_context_version_ = 0;
    mutable std::vector<RingElement> powers_;
};
```

### 2.3 RAII 模数保护

```cpp
/**
 * @brief RAII 模数上下文保护器
 * 
 * 确保在进入 BGV 操作时设置正确模数，
 * 退出时恢复原始模数，防止污染。
 */
class ModulusGuard {
public:
    explicit ModulusGuard(const ZZ& q)
        : backup_()
    {
        backup_.save();
        ZZ_p::init(q);
    }
    
    ~ModulusGuard() {
        backup_.restore();
    }
    
    // Non-copyable, non-movable
    ModulusGuard(const ModulusGuard&) = delete;
    ModulusGuard& operator=(const ModulusGuard&) = delete;

private:
    ZZ_pBak backup_;
};

// 使用示例
BGVCiphertext BGVContext::encrypt(const BGVPublicKey& pk, const BGVPlaintext& pt) {
    ModulusGuard guard(ciphertext_modulus_);  // 自动保护/恢复
    
    // ... 加密逻辑 ...
    
    return ct;  // guard 析构时恢复原始模数
}
```

### 2.4 文档化全局状态依赖

在头文件中明确标注哪些方法依赖全局状态：

```cpp
/**
 * @brief 计算密文乘法
 * 
 * @warning GLOBAL_STATE_DEPENDENT: 此方法依赖 NTL ZZ_p 全局模数
 *          调用前应使用 ModulusGuard 或 ZZ_pBak 保护
 * 
 * @param ct1 第一个密文
 * @param ct2 第二个密文
 * @return 乘积密文
 */
BGVCiphertext multiply(const BGVCiphertext& ct1, const BGVCiphertext& ct2);
```

---

## 3. 深度测试设计

### 3.1 链式操作测试

```cpp
// 测试 x^8 = ((x^2)^2)^2
TEST(BGVChainTest, PowerOfEight) {
    auto ctx = make_context();
    auto [sk, pk, rk] = ctx.generate_keys();
    
    auto ct = ctx.encrypt(pk, encode(3));  // 3
    
    // 8 次链式乘法
    for (int i = 0; i < 3; i++) {
        ct = ctx.multiply(ct, ct);
        ct = ctx.relinearize(ct, rk);
    }
    
    auto result = ctx.decrypt(sk, ct);
    EXPECT_EQ(result, encode(6561));  // 3^8 = 6561
}
```

### 3.2 多上下文交叉测试

```cpp
TEST(BGVMultiContextTest, CrossContextNoContamination) {
    // 创建两个不同参数的上下文
    auto ctx1 = make_context(BGVParams::TOY_PARAMS);
    auto ctx2 = make_context(BGVParams::SMALL_PARAMS);
    
    auto sk1 = ctx1.generate_secret_key();
    auto sk2 = ctx2.generate_secret_key();
    
    // ctx1 操作
    auto pk1 = ctx1.generate_public_key(sk1);
    auto ct1 = ctx1.encrypt(pk1, encode(42));
    
    // 切换到 ctx2 操作
    auto pk2 = ctx2.generate_public_key(sk2);
    auto ct2 = ctx2.encrypt(pk2, encode(100));
    
    // 回到 ctx1 解密 - 应该正确，不受 ctx2 影响
    auto result1 = ctx1.decrypt(sk1, ct1);
    EXPECT_EQ(result1, encode(42));
    
    // ctx2 解密
    auto result2 = ctx2.decrypt(sk2, ct2);
    EXPECT_EQ(result2, encode(100));
}
```

### 3.3 缓存失效测试

```cpp
TEST(BGVCacheTest, CacheInvalidationOnContextSwitch) {
    auto ctx1 = make_context();
    auto sk = ctx1.generate_secret_key();
    
    // 计算 sk.power(2) 并缓存
    auto s2_v1 = sk.power(2, ctx1);
    
    // 创建新上下文（不同版本）
    auto ctx2 = make_context();
    
    // 使用新上下文计算 power - 应该重新计算，不使用旧缓存
    auto s2_v2 = sk.power(2, ctx2);
    
    // 两个结果应该在各自上下文中正确
    // (内容可能相同，但必须在正确的模数下计算)
}
```

---

## 4. 实现计划

### 4.1 文件修改

| 文件 | 修改内容 |
|------|---------|
| `bgv_context.hpp` | 添加 `version_`、`ModulusGuard` 类 |
| `bgv_context.cpp` | 实现版本控制、RAII 保护 |
| `bgv_evaluator.cpp` | 所有操作添加 ModulusGuard |
| `test_bgv.cpp` | 添加链式测试、多上下文测试 |

### 4.2 接口变更

**新增方法**:
- `BGVContext::version() -> uint64_t`
- `BGVSecretKey::power(k, ctx)` (带上下文版本)
- `BGVSecretKey::invalidate_cache()`

**废弃方法**:
- `BGVSecretKey::power(k)` (无上下文版本) - 标记 [[deprecated]]

---

## 5. 验收标准

1. ✅ 所有现有测试通过 (原230 → 现235)
2. ✅ 新增深度链操作测试 (DeepChainSquareTest)
3. ✅ 新增多上下文交叉测试 (MultiContextCrossTest, AlternatingContextOperations)
4. ✅ 新增缓存失效测试 (SecretKeyPowerCacheInvalidation, ContextVersioningTest)
5. ✅ 代码审查：ModulusGuard 类已实现，ZZ_pBak 保护
6. ⏳ Valgrind 无内存泄漏 (待 Linux 环境验证)

---

## 6. 实际实现摘要

### 6.1 新增文件/类
- `ModulusGuard` 类 (RAII 模数保护)
- `BGVContext::version()` / `version_` 成员
- `BGVSecretKey::power(k, ctx_version)` 带版本参数
- `BGVSecretKey::invalidate_power_cache()` 显式失效方法

### 6.2 新增测试 (5个)
| 测试名 | 描述 |
|--------|------|
| MultiContextCrossTest | 两个独立上下文不互相干扰 |
| DeepChainSquareTest | 多值平方操作正确性 |
| ContextVersioningTest | 上下文版本单调递增 |
| SecretKeyPowerCacheInvalidation | 缓存失效机制 |
| AlternatingContextOperations | 三上下文交替操作 |

### 6.3 测试结果
```
100% tests passed, 0 tests failed out of 235
```

---

*文档版本: v4.6.0-phase0*
*创建日期: 2026-01-22*
*完成日期: 2026-01-22*
*作者: knightc*

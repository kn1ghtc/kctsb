# kctsb v4.8.0 Phase 3 设计文档 - CKKS 近似同态加密

> **版本**: v4.8.0 Phase 3  
> **日期**: 2026-01-22 (Beijing Time, UTC+8)  
> **状态**: ✅ **已完成**
> **完成日期**: 2026-01-23 (Beijing Time, UTC+8)

---

## 0. 背景与动机

### 0.1 Phase 1-3 回顾

| Phase | 内容 | 状态 | 测试 |
|-------|------|------|------|
| Phase 1 | BGV NTT 加速 | ✅ 完成 | 43/43 |
| Phase 2 | BFV 实现 | ✅ 完成 | 25/25 |
| Phase 3 | **CKKS 近似计算** | ✅ **完成** | **33/33** |

### 0.2 为什么需要 CKKS

| 场景 | BGV/BFV | CKKS |
|------|---------|------|
| **精确整数** | ✅ 最优 | ❌ 有精度损失 |
| **浮点/实数** | ❌ 需要定点转换 | ✅ 原生支持 |
| **ML推理** | 可行但复杂 | ✅ 最优选择 |
| **统计计算** | 可行但繁琐 | ✅ 自然表达 |

**核心价值**: CKKS 允许对加密的浮点数进行同态运算，是 SEAL、OpenFHE 的核心方案。

---

## 1. Phase 3 目标

### 1.1 核心目标

| 目标 | 描述 | 验收标准 | 优先级 |
|------|------|----------|--------|
| **CKKS 基础实现** | 复数/浮点编码方案 | 单次 add/multiply 正确 | P0 |
| **Rescale 机制** | 乘法后模数切换 | 精度在预期范围内 | P0 |
| **多层计算** | 支持 3-5 层乘法深度 | 累积误差可控 | P1 |
| **Benchmark** | CKKS vs BFV vs SEAL | 性能数据 | P1 |
| **统一接口** | BGV/BFV/CKKS 共享基础 | 复用率 > 70% | P2 |

### 1.2 Phase 3 不做的事情

- 性能优化到 SEAL 级别（需要 RNSPoly，留给 Phase 4）
- Bootstrapping（超出 MVP 范围）
- 批量 slot packing 优化

### 1.3 性能目标 (现实目标)

| 操作 | 当前 BFV (ms) | Phase 3 CKKS 目标 (ms) | SEAL 参考 (ms) |
|------|-------------|------------------------|---------------|
| Multiply | 3,295 | < 5,000 | ~10 |
| Encrypt | 8,501 | < 10,000 | ~5 |
| Rescale | N/A | < 2,000 | ~5 |

**说明**: Phase 3 专注正确性，性能优化留给 Phase 4 RNSPoly 重构。

---

## 2. CKKS 理论基础

### 2.1 CKKS vs BGV/BFV 核心差异

| 特性 | BGV | BFV | CKKS |
|------|-----|-----|------|
| **消息域** | $\mathbb{Z}_t$ (整数) | $\mathbb{Z}_t$ (整数) | $\mathbb{C}^{N/2}$ (复数向量) |
| **编码** | 直接嵌入 | Δ-缩放 | 正则嵌入 (canonical embedding) |
| **缩放因子** | 无 | $\Delta = \lfloor q/t \rfloor$ | $\Delta$ (用户指定，如 $2^{40}$) |
| **乘法后** | 模数切换 | Rescale | Rescale |
| **噪声模型** | 精确，可追踪 | 精确 | 近似，与精度耦合 |

### 2.2 CKKS 数学定义

**正则嵌入 (Canonical Embedding)**:
$$\sigma: \mathbb{Z}[X]/(X^N+1) \to \mathbb{C}^N$$
$$\sigma(a(X)) = (a(\zeta), a(\zeta^3), \ldots, a(\zeta^{2N-1}))$$

其中 $\zeta = e^{i\pi/N}$ 是 $2N$ 次本原单位根。

**编码 (Encode)**:
$$\text{encode}(z_1, \ldots, z_{N/2}) = \lfloor \Delta \cdot \sigma^{-1}(z_1, \bar{z}_1, z_2, \bar{z}_2, \ldots) \rceil \mod q$$

**解码 (Decode)**:
$$\text{decode}(m) = \sigma(m) / \Delta$$

**同态乘法后的 Rescale**:
$$\text{rescale}(c) = \lfloor c / p \rceil \mod (q/p)$$

这将 scale 从 $\Delta^2$ 降回 $\Delta$。

### 2.3 精度分析

CKKS 的近似性质来源于两个因素：

1. **编码舍入误差**: $\lfloor \Delta \cdot m \rceil$ 引入 $\pm 0.5$ 误差
2. **Rescale 舍入误差**: $\lfloor c/p \rceil$ 引入额外误差

**单次乘法后精度**:
$$|m - \text{decode}(\text{decrypt}(\text{multiply}(...)))| \lesssim 1/\Delta$$

**多层乘法精度**:
$$\epsilon_L \approx \epsilon_0 \cdot L \cdot k$$

其中 $L$ 是乘法层数，$k$ 是常数。

---

## 3. 技术方案

### 3.1 架构设计

```
CKKS 复用 BGV/BFV 基础设施:
┌─────────────────────────────────────────────────┐
│ CKKS API Layer (ckks.hpp)                       │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │
│ │ CKKSParams  │ │ CKKSContext │ │ CKKSEncoder │ │
│ │CKKSEvaluator│ │ Rescaler    │              │ │
│ └─────────────┘ └─────────────┘ └─────────────┘ │
└─────────────────────────────────────────────────┘
                      │
                      ▼ 委托（密钥生成、多项式运算）
┌─────────────────────────────────────────────────┐
│ BGV Core Layer (bgv.hpp)                        │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │
│ │BGVSecretKey │ │BGVPublicKey │ │ BGVCipher   │ │
│ │BGVContext   │ │BGVEvaluator │ │ RingPoly    │ │
│ └─────────────┘ └─────────────┘ └─────────────┘ │
└─────────────────────────────────────────────────┘
```

### 3.2 CKKSParams 设计

```cpp
struct CKKSParams {
    size_t m;               // 分圆多项式阶 (2*n)
    size_t n;               // 多项式度 (2的幂)
    size_t L;               // 乘法深度
    double scale;           // 初始缩放因子 (如 2^40)
    std::vector<uint64_t> primes;  // RNS 模数链
    double sigma;           // 高斯采样标准差
    size_t security;        // 安全级别 bits
    
    // 参数集
    static CKKSParams TOY_PARAMS();        // n=256, L=2 (测试)
    static CKKSParams SECURITY_128();      // n=8192, L=4 (128-bit)
    static CKKSParams SECURITY_192();      // n=16384, L=8 (192-bit)
};
```

### 3.3 CKKSEncoder 设计

**核心挑战**: 实现正则嵌入（FFT 变换）

```cpp
class CKKSEncoder {
public:
    explicit CKKSEncoder(const CKKSContext& ctx);
    
    // 编码复数向量为明文多项式
    // values: N/2 个复数
    // scale: 缩放因子 (默认使用参数中的 scale)
    Plaintext encode(const std::vector<std::complex<double>>& values,
                     double scale = 0.0);
    
    // 编码实数向量 (虚部为 0)
    Plaintext encode_real(const std::vector<double>& values,
                          double scale = 0.0);
    
    // 解码明文为复数向量
    std::vector<std::complex<double>> decode(const Plaintext& pt);
    
    // 解码实数部分
    std::vector<double> decode_real(const Plaintext& pt);
    
private:
    const CKKSContext& ctx_;
    
    // FFT 相关
    std::vector<std::complex<double>> roots_;  // 单位根预计算
    
    // 正则嵌入
    std::vector<std::complex<double>> canonical_embedding(
        const std::vector<std::complex<double>>& coeffs);
    
    // 逆嵌入
    std::vector<std::complex<double>> inverse_embedding(
        const std::vector<std::complex<double>>& values);
};
```

### 3.4 Rescale 机制

**Rescale 是 CKKS 的核心操作**，用于在乘法后降低 scale：

```cpp
class CKKSEvaluator {
public:
    // 乘法 (scale 变为 Δ²)
    Ciphertext multiply(const Ciphertext& ct1, const Ciphertext& ct2);
    
    // Rescale: 将 scale 从 Δ² 降回 Δ
    // 同时将模数从 q_l 降到 q_{l-1} = q_l / p_l
    Ciphertext rescale(const Ciphertext& ct);
    
    // 便捷方法: 乘法 + rescale
    Ciphertext multiply_rescale(const Ciphertext& ct1, const Ciphertext& ct2);
    
    // 模数切换 (不改变 scale，用于噪声管理)
    Ciphertext mod_switch(const Ciphertext& ct);
    
private:
    // Rescale 实现: c' = round(c / p_l) mod q_{l-1}
    void rescale_impl(Ciphertext& ct);
};
```

### 3.5 Level 管理

CKKS 使用 RNS 模数链 $q = \prod_{i=0}^{L} p_i$：

```cpp
struct CKKSCiphertext {
    std::vector<RingElement> components;
    size_t level;           // 当前层级 (从 L 开始，每次 rescale 减 1)
    double scale;           // 当前 scale
    
    // 检查是否还能继续计算
    bool can_multiply() const { return level > 0; }
    
    // 获取当前模数
    ZZ get_modulus() const;
};
```

---

## 4. 实现计划

### 4.1 文件结构

```
kctsb/
├── include/kctsb/advanced/fe/ckks/
│   └── ckks.hpp              # CKKS 公共 API
├── src/advanced/fe/ckks/
│   ├── ckks_context.cpp      # Context 实现
│   ├── ckks_encoder.cpp      # FFT 编码器
│   └── ckks_evaluator.cpp    # 同态运算 + Rescale
└── tests/
    ├── unit/fhe/test_ckks.cpp        # 单元测试
    └── benchmark/test_ckks_benchmark.cpp  # 性能测试
```

### 4.2 实现顺序

| 步骤 | 组件 | 依赖 | 预估行数 |
|------|------|------|----------|
| 1 | CKKSParams | - | 80 |
| 2 | CKKSEncoder (FFT) | Step 1 | 200 |
| 3 | CKKSContext | Step 1 | 100 |
| 4 | CKKSCiphertext | BGV | 50 |
| 5 | CKKSEvaluator (add) | Step 3,4 | 80 |
| 6 | CKKSEvaluator (multiply) | Step 5 | 100 |
| 7 | Rescale 实现 | Step 6 | 150 |
| 8 | 单元测试 | All | 400 |
| 9 | Benchmark | All | 200 |

**总计**: ~1,360 行新代码

### 4.3 FFT 实现策略

CKKS 编码需要 FFT（快速傅里叶变换）来实现正则嵌入：

**选项 1**: 使用 NTL 的 FFT（已有依赖）
**选项 2**: 实现自己的 Radix-2 FFT
**选项 3**: 使用简化的 O(N²) DFT（仅用于正确性验证）

**Phase 3 决策**: 使用选项 3（简化 DFT）确保正确性，Phase 4 优化为 FFT。

```cpp
// 简化 DFT 实现 (O(N²)，仅用于正确性验证)
std::vector<std::complex<double>> dft(
    const std::vector<std::complex<double>>& x) {
    size_t n = x.size();
    std::vector<std::complex<double>> X(n);
    
    for (size_t k = 0; k < n; k++) {
        X[k] = {0.0, 0.0};
        for (size_t j = 0; j < n; j++) {
            double angle = -2.0 * M_PI * k * j / n;
            std::complex<double> w(cos(angle), sin(angle));
            X[k] += x[j] * w;
        }
    }
    
    return X;
}
```

---

## 5. 验收标准

### 5.1 功能验收

| 测试项 | 验收标准 |
|--------|----------|
| CKKS 编码/解码 | encode(z) → decode() ≈ z, 误差 < 1e-7 |
| CKKS 加密/解密 | encrypt(pt) → decrypt() ≈ pt |
| CKKS 加法 | ct1 + ct2 解密正确，误差 < 1e-6 |
| CKKS 乘法 | ct1 * ct2 解密正确，误差 < 1e-5 |
| Rescale | 乘法后 rescale 保持精度 |
| 多层计算 | 3 层乘法，累积误差 < 1e-3 |

### 5.2 测试矩阵

| 测试类别 | 测试数量 | 覆盖范围 |
|----------|----------|----------|
| CKKSEncoderTest | 6 | encode/decode/FFT |
| CKKSContextTest | 4 | 参数/密钥生成 |
| CKKSEncryptionTest | 5 | encrypt/decrypt |
| CKKSOperationTest | 8 | add/multiply/rescale |
| CKKSPrecisionTest | 5 | 精度验证 |
| CKKSDepthTest | 3 | 多层乘法 |

**总计**: ~31 个 CKKS 测试用例

### 5.3 精度验收

| 操作 | 精度要求 | 备注 |
|------|----------|------|
| 编码/解码 | 相对误差 < 1e-7 | 纯 FFT 精度 |
| 加密/解密 | 相对误差 < 1e-6 | 包含噪声 |
| 加法 | 相对误差 < 1e-6 | 加法性噪声 |
| 乘法 (无 rescale) | 相对误差 < 1e-5 | scale 加倍 |
| 乘法 + rescale | 相对误差 < 1e-4 | rescale 引入额外误差 |
| 3 层乘法 | 相对误差 < 1e-2 | 累积误差 |

---

## 6. 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| FFT 精度不足 | 中 | 高 | 使用 long double 或验证精度 |
| Rescale 噪声过大 | 中 | 高 | 参考 SEAL 参数选择 |
| 多层乘法误差累积 | 中 | 中 | 限制初始 scale 选择 |
| 与 BGV/BFV 接口冲突 | 低 | 低 | 使用独立命名空间 |

---

## 7. Phase 4 展望 (性能优化)

**目标**: 将所有 FHE 方案性能提升到 SEAL 的 10x 以内

| 优化项 | 预期提升 | 复杂度 | 适用方案 |
|--------|----------|--------|----------|
| RNSPoly 原生实现 | 10-50x | 高 | 全部 |
| FFT 替换 DFT | 10x 编码 | 中 | CKKS |
| AVX2 密钥操作 | 2-3x | 中 | 全部 |
| 批量随机采样 | 5-10x Encrypt | 低 | 全部 |

---

*Phase 3 设计文档结束 - 开始实施*

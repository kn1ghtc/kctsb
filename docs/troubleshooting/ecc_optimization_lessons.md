# ECC Optimization Lessons Learned

> **Date**: 2026-01-19 to 2026-01-20 (Beijing Time)
> **Context**: P-256 performance optimization attempts

## Overview

This document captures lessons learned from attempting to optimize P-256 curve performance to reach 80% of OpenSSL performance.

## Performance Baseline

| Curve | kctsb | OpenSSL | Ratio |
|-------|-------|---------|-------|
| secp256k1 KeyGen | 0.64ms | 0.43ms | **67%** |
| secp256k1 Sign | 1.2ms | 0.6ms | **50%** |
| P-256 KeyGen | 0.78ms | 0.017ms | **2%** |
| P-256 Sign | 2.1ms | 0.075ms | **3.5%** |
| P-256 Verify | 3.2ms | 0.15ms | **4.8%** |

## Why secp256k1 is Faster (35-67% of OpenSSL)

1. **Simple Prime Structure**: p = 2^256 - 2^32 - 977
   - Only needs one 64-bit multiply for reduction
   - No complex Solinas reduction needed

2. **a = 0 Optimization**: 
   - Point doubling is simpler
   - Fewer field multiplications

3. **Wide Adoption**: 
   - Bitcoin uses this curve
   - Many optimized implementations available

## Why P-256 is Slower (~2-5% of OpenSSL)

### Root Cause: Assembly vs C++

OpenSSL uses `ecp_nistz256` which is written in **hand-optimized x86_64 assembly**:

```asm
# OpenSSL crypto/ec/asm/ecp_nistz256-x86_64.pl
# Uses MULX (BMI2) and ADCX/ADOX (ADX) instructions
# Pipeline-optimized Montgomery multiplication
```

Key assembly optimizations:
1. **MULX instruction**: Non-destructive multiply, uses implicit rdx
2. **ADCX/ADOX**: Two independent carry chains for parallelism
3. **Interleaved scheduling**: Hides latency through instruction interleaving
4. **No function call overhead**: All inlined

### What We Tried

1. **Solinas Reduction** ✅
   - Implemented NIST FIPS 186-4 Appendix D.2.3 formula
   - Works correctly but still slow due to multiple passes

2. **Montgomery Multiplication Attempt** ❌
   - Tried implementing true CIOS Montgomery multiplication
   - Tests failed because they expect direct modular results, not Montgomery form
   - Would require API changes to properly support

3. **Precomputation Table Caching** ✅
   - Added generator point precomputation tables
   - Small improvement (~5-10%) but not enough

## Key Lessons

### 1. Pure C++ Cannot Match Assembly for Field Arithmetic

Modern CPUs have specialized instructions (ADX, BMI2) that cannot be efficiently generated by compilers:

```cpp
// C++ code - compiler generates suboptimal assembly
uint64_t adc64(uint64_t a, uint64_t b, uint64_t carry_in, uint64_t* carry_out) {
    __uint128_t sum = (__uint128_t)a + b + carry_in;
    *carry_out = sum >> 64;
    return (uint64_t)sum;
}

// vs. Hand-optimized assembly
// ADCX uses implicit carry flag, no memory operations
```

### 2. Montgomery Form Requires API Changes

True Montgomery multiplication returns values in Montgomery form:
```
Mont(a, b) = a * b * R^(-1) mod p  (where R = 2^256)
```

Tests expect direct modular results:
```cpp
// Test expects: 2 * 3 = 6
// Montgomery returns: 2 * 3 * R^(-1) mod p ≠ 6
```

Supporting Montgomery would require:
- Converting all inputs to Montgomery form on entry
- Converting all outputs from Montgomery form on exit
- Changing all test expectations

### 3. secp256k1 Shows C++ Can Be Competitive

For curves with simple prime structure (secp256k1), C++ can achieve 35-67% of OpenSSL. The optimization gap is primarily in field arithmetic, not point operations.

## Recommendations

### To Reach 80% of OpenSSL for P-256:

1. **Add Assembly for Field Arithmetic**
   - Implement `fe256_mul_mont_p256_asm()` using ADX/BMI2
   - Use `fe256_x86_64.S` as starting point
   - Reference OpenSSL's `ecp_nistz256-x86_64.pl`

2. **Consider SIMD Optimizations**
   - AVX2/AVX-512 for parallel field operations
   - Useful for batch operations

3. **GLV Decomposition** (for secp256k1)
   - Split scalar k = k1 + k2*λ
   - Compute k1*P + k2*ψ(P) in half the time

### For Production Use:

If P-256 performance is critical, consider:
1. Using platform-specific assembly paths
2. Linking against OpenSSL for P-256 operations
3. Using secp256k1 if curve choice is flexible

## Related Files

- `src/crypto/ecc/fe256_p256.cpp` - P-256 Solinas reduction
- `src/crypto/ecc/asm/fe256_x86_64.S` - secp256k1 assembly (starting point)
- OpenSSL: `crypto/ec/asm/ecp_nistz256-x86_64.pl`

## References

- [Intel ADX Architecture](https://software.intel.com/content/www/us/en/develop/articles/intel-adx-new-instructions-for-accelerating-big-number-arithmetic.html)
- [OpenSSL P-256 Implementation](https://github.com/openssl/openssl/blob/master/crypto/ec/asm/ecp_nistz256-x86_64.pl)
- [NIST FIPS 186-4 Appendix D](https://csrc.nist.gov/publications/detail/fips/186/4/final)

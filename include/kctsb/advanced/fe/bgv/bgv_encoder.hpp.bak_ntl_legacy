/**
 * @file bgv_encoder.hpp
 * @brief BGV Plaintext Encoding/Decoding
 * 
 * Provides encoding schemes for converting user data to BGV plaintexts:
 * - Integer encoding: Single integer values
 * - Batch encoding: SIMD slots using CRT decomposition
 * 
 * @author knightc
 * @copyright Copyright (c) 2019-2026 knightc. All rights reserved.
 * @license Apache-2.0
 */

#ifndef KCTSB_ADVANCED_FE_BGV_ENCODER_HPP
#define KCTSB_ADVANCED_FE_BGV_ENCODER_HPP

#include "bgv_types.hpp"
#include <vector>
#include <complex>

namespace kctsb {
namespace fhe {
namespace bgv {

/**
 * @brief BGV Batch Encoder
 * 
 * Encodes vectors of integers into plaintext polynomials using
 * the Chinese Remainder Theorem (CRT) decomposition of Z_t[X]/(Φ_m(X)).
 * 
 * For m with ℓ distinct prime factors of (m,t), the ring decomposes into
 * slot_count() independent slots, enabling SIMD operations.
 */
class BGVEncoder {
public:
    /**
     * @brief Construct encoder for given context
     * @param context BGV context
     */
    explicit BGVEncoder(const BGVContext& context);
    
    /// Get number of available slots
    uint64_t slot_count() const { return slot_count_; }
    
    // ==================== Integer Encoding ====================
    
    /**
     * @brief Encode single integer
     * @param value Integer value (will be reduced mod t)
     * @return Plaintext polynomial
     */
    BGVPlaintext encode(int64_t value) const;
    
    /**
     * @brief Encode ZZ integer
     * @param value Big integer (will be reduced mod t)
     * @return Plaintext polynomial
     */
    BGVPlaintext encode(const ZZ& value) const;
    
    /**
     * @brief Decode single integer from coefficient 0
     * @param pt Plaintext
     * @return Decoded integer
     */
    int64_t decode_int(const BGVPlaintext& pt) const;
    
    ZZ decode_zz(const BGVPlaintext& pt) const;
    
    // ==================== Batch Encoding (SIMD) ====================
    
    /**
     * @brief Encode vector into SIMD slots
     * 
     * Each slot can hold an independent value mod t.
     * Vector size must be <= slot_count().
     * 
     * @param values Vector of integers
     * @return Batched plaintext
     */
    BGVPlaintext encode_batch(const std::vector<int64_t>& values) const;
    
    BGVPlaintext encode_batch(const std::vector<uint64_t>& values) const;
    
    BGVPlaintext encode_batch(const vec_ZZ& values) const;
    
    /**
     * @brief Decode SIMD slots to vector
     * @param pt Batched plaintext
     * @return Vector of slot values
     */
    std::vector<int64_t> decode_batch(const BGVPlaintext& pt) const;
    
    std::vector<uint64_t> decode_batch_unsigned(const BGVPlaintext& pt) const;
    
    vec_ZZ decode_batch_zz(const BGVPlaintext& pt) const;
    
    // ==================== Polynomial Encoding ====================
    
    /**
     * @brief Encode coefficient vector as polynomial
     * 
     * coeffs[i] becomes the coefficient of X^i.
     * 
     * @param coeffs Coefficient vector
     * @return Plaintext polynomial
     */
    BGVPlaintext encode_poly(const std::vector<int64_t>& coeffs) const;
    
    /**
     * @brief Decode polynomial to coefficient vector
     */
    std::vector<int64_t> decode_poly(const BGVPlaintext& pt) const;
    
    // ==================== Utility ====================
    
    /// Get associated context
    const BGVContext& context() const { return context_; }
    
    /// Plaintext modulus
    uint64_t plaintext_modulus() const { return t_; }

private:
    const BGVContext& context_;
    uint64_t t_;             ///< Plaintext modulus
    uint64_t slot_count_;    ///< Number of SIMD slots
    
    // CRT basis for batch encoding
    std::vector<ZZ_pX> crt_basis_;
    std::vector<ZZ_pX> crt_basis_inv_;
    
    // Slot-to-coefficient mapping (for NTT-based encoding)
    std::vector<uint64_t> slot_mapping_;
    std::vector<uint64_t> slot_mapping_inv_;
    
    // Initialize CRT decomposition
    void initialize_batch_encoder();
};

/**
 * @brief Simple coefficient encoder (non-batched)
 * 
 * Encodes data directly as polynomial coefficients.
 * Simpler than batch encoding but no SIMD parallelism.
 */
class BGVCoeffEncoder {
public:
    explicit BGVCoeffEncoder(const BGVContext& context);
    
    /// Encode integer as constant polynomial
    BGVPlaintext encode(int64_t value) const;
    
    /// Encode vector as polynomial coefficients
    BGVPlaintext encode(const std::vector<int64_t>& coeffs) const;
    
    /// Decode constant term
    int64_t decode(const BGVPlaintext& pt) const;
    
    /// Decode all coefficients
    std::vector<int64_t> decode_all(const BGVPlaintext& pt) const;

private:
    const BGVContext& context_;
    uint64_t t_;
    uint64_t n_;
};

} // namespace bgv
} // namespace fhe
} // namespace kctsb

#endif // KCTSB_ADVANCED_FE_BGV_ENCODER_HPP

/**
 * @file bfv.hpp
 * @brief BFV (Brakerski/Fan-Vercauteren) Homomorphic Encryption Scheme
 * 
 * BFV is a scale-invariant homomorphic encryption scheme that allows
 * computation on encrypted integers. Unlike BGV, BFV uses a scaling
 * factor Δ = floor(q/t) in the encoding, making noise management simpler.
 * 
 * Key differences from BGV:
 * - Encoding: m → Δ·m (scaled by floor(q/t))
 * - After multiplication: rescale by dividing by Δ
 * - Noise growth: constant per level (scale-invariant)
 * 
 * @note This implementation reuses BGV infrastructure for maximum code reuse.
 * 
 * @author knightc
 * @copyright Copyright (c) 2019-2026 knightc. All rights reserved.
 * @license Apache-2.0
 */

#ifndef KCTSB_ADVANCED_FE_BFV_BFV_HPP
#define KCTSB_ADVANCED_FE_BFV_BFV_HPP

#include "kctsb/advanced/fe/bgv/bgv.hpp"
#include <memory>

namespace kctsb::fhe::bfv {

// ============================================================================
// Type Aliases - Reuse BGV types for maximum compatibility
// ============================================================================

using SecretKey = bgv::BGVSecretKey;
using PublicKey = bgv::BGVPublicKey;
using RelinKey = bgv::BGVRelinKey;
using Ciphertext = bgv::BGVCiphertext;
using Plaintext = bgv::BGVPlaintext;
using RingElement = bgv::RingElement;
using ZZ = kctsb::ZZ;
using ZZ_p = kctsb::ZZ_p;
using ZZ_pX = kctsb::ZZ_pX;

// Forward declarations
class BFVContext;
class BFVEncoder;
class BFVEvaluator;

// ============================================================================
// BFV Parameters
// ============================================================================

/**
 * @brief BFV encryption parameters
 * 
 * BFV uses the same ring structure as BGV (R_q = Z_q[X]/(X^n+1))
 * but with scale-invariant encoding: m → Δ·m where Δ = floor(q/t).
 */
struct BFVParams {
    // Ring parameters (match BGVParams structure)
    uint64_t m = 0;         ///< Cyclotomic index
    size_t n = 0;           ///< Polynomial degree (must be power of 2)
    uint64_t t = 0;         ///< Plaintext modulus
    ZZ q;                   ///< Ciphertext modulus
    std::vector<uint64_t> primes;  ///< RNS decomposition primes
    size_t L = 0;           ///< Modulus chain depth
    double sigma = 3.2;     ///< Error distribution std dev
    bgv::SecurityLevel security = bgv::SecurityLevel::NONE;
    
    /**
     * @brief Compute scaling factor Δ = floor(q/t)
     * @return The BFV scaling factor
     */
    ZZ delta() const { 
        return q / ZZ(t); 
    }
    
    /**
     * @brief Create standard BFV parameters
     * @param ring_degree Polynomial degree n (power of 2)
     * @param plain_modulus Plaintext modulus t
     * @return BFV parameters suitable for 128-bit security
     */
    static BFVParams create_from_bgv(const bgv::BGVParams& bgv_params);
    
    /**
     * @brief Convert to BGV parameters (for internal use)
     * @return Equivalent BGV parameters
     */
    bgv::BGVParams to_bgv_params() const;
};

/**
 * @brief Standard BFV parameter sets
 */
struct StandardParams {
    /**
     * @brief Toy parameters for testing (n=256)
     * @note NOT cryptographically secure!
     */
    static BFVParams TOY_PARAMS();
    
    /**
     * @brief 128-bit security, depth 3 (n=4096)
     */
    static BFVParams SECURITY_128_DEPTH_3();
    
    /**
     * @brief 128-bit security, depth 5 (n=8192)
     * @note Industry standard for SEAL comparison
     */
    static BFVParams SECURITY_128();
};

// ============================================================================
// BFV Context
// ============================================================================

/**
 * @brief BFV encryption context
 * 
 * Manages parameters, key generation, encryption and decryption.
 * Internally delegates to BGV context for most operations.
 */
class BFVContext {
public:
    /**
     * @brief Construct BFV context from parameters
     * @param params BFV encryption parameters
     */
    explicit BFVContext(const BFVParams& params);
    
    // Key generation
    SecretKey generate_secret_key();
    PublicKey generate_public_key(const SecretKey& sk);
    RelinKey generate_relin_key(const SecretKey& sk);
    
    // Encryption/Decryption with BFV encoding
    Ciphertext encrypt(const PublicKey& pk, const Plaintext& pt);
    Ciphertext encrypt_symmetric(const SecretKey& sk, const Plaintext& pt);
    Plaintext decrypt(const SecretKey& sk, const Ciphertext& ct);
    
    // Parameter access
    const BFVParams& params() const { return params_; }
    size_t ring_degree() const { return params_.n; }
    uint64_t plaintext_modulus() const { return params_.t; }
    ZZ delta() const { return params_.delta(); }
    size_t slot_count() const { return params_.n; }
    
    // Access internal BGV context
    const bgv::BGVContext& bgv_context() const { return *bgv_ctx_; }
    
private:
    BFVParams params_;
    std::unique_ptr<bgv::BGVContext> bgv_ctx_;
};

// ============================================================================
// BFV Encoder
// ============================================================================

/**
 * @brief BFV plaintext encoder
 * 
 * Encodes integers using BFV's scale-invariant encoding:
 * encode(m) = Δ·m mod q, where Δ = floor(q/t)
 */
class BFVEncoder {
public:
    /**
     * @brief Construct encoder from context
     * @param ctx BFV context
     */
    explicit BFVEncoder(const BFVContext& ctx);
    
    /**
     * @brief Encode a single integer
     * @param value Integer in range [-(t-1)/2, (t-1)/2] or [0, t-1]
     * @return Scaled plaintext Δ·value mod q
     */
    Plaintext encode(int64_t value);
    
    /**
     * @brief Encode a batch of integers (coefficient packing)
     * @param values Vector of integers
     * @return Plaintext with values as coefficients
     */
    Plaintext encode_batch(const std::vector<int64_t>& values);
    
    /**
     * @brief Decode plaintext to single integer
     * @param pt Plaintext to decode
     * @return Decoded integer round(pt[0] / Δ) mod t
     */
    int64_t decode(const Plaintext& pt);
    
    /**
     * @brief Decode batch of integers
     * @param pt Plaintext to decode
     * @return Vector of decoded integers
     */
    std::vector<int64_t> decode_batch(const Plaintext& pt);
    
    /**
     * @brief Get slot count (number of values that can be packed)
     * @return Ring degree n
     */
    size_t slot_count() const { return ctx_.ring_degree(); }
    
private:
    const BFVContext& ctx_;
    ZZ delta_;
};

// ============================================================================
// BFV Evaluator
// ============================================================================

/**
 * @brief BFV homomorphic operations
 * 
 * Provides addition, multiplication with automatic rescaling,
 * and relinearization operations on BFV ciphertexts.
 */
class BFVEvaluator {
public:
    /**
     * @brief Construct evaluator from context
     * @param ctx BFV context
     */
    explicit BFVEvaluator(const BFVContext& ctx);
    
    // ========== Addition ==========
    
    /**
     * @brief Add two ciphertexts
     * @param ct1 First ciphertext
     * @param ct2 Second ciphertext
     * @return ct1 + ct2
     */
    Ciphertext add(const Ciphertext& ct1, const Ciphertext& ct2);
    
    /**
     * @brief Add plaintext to ciphertext
     * @param ct Ciphertext
     * @param pt Plaintext (must be BFV-encoded with Δ scaling)
     * @return ct + pt
     */
    Ciphertext add_plain(const Ciphertext& ct, const Plaintext& pt);
    
    /**
     * @brief Subtract two ciphertexts
     * @param ct1 First ciphertext
     * @param ct2 Second ciphertext
     * @return ct1 - ct2
     */
    Ciphertext sub(const Ciphertext& ct1, const Ciphertext& ct2);
    
    // ========== Multiplication ==========
    
    /**
     * @brief Multiply two ciphertexts (no rescale)
     * @param ct1 First ciphertext
     * @param ct2 Second ciphertext
     * @return ct1 * ct2 (scale becomes Δ²)
     * @note Result has 3 components. Use relinearize() to reduce to 2.
     */
    Ciphertext multiply_raw(const Ciphertext& ct1, const Ciphertext& ct2);
    
    /**
     * @brief Multiply and rescale
     * @param ct1 First ciphertext
     * @param ct2 Second ciphertext
     * @return rescale(ct1 * ct2) (scale becomes Δ)
     */
    Ciphertext multiply(const Ciphertext& ct1, const Ciphertext& ct2);
    
    /**
     * @brief Multiply ciphertext by plaintext
     * @param ct Ciphertext
     * @param pt Plaintext (NOT Δ-scaled, raw value)
     * @return ct * pt
     */
    Ciphertext multiply_plain(const Ciphertext& ct, const Plaintext& pt);
    
    // ========== Rescale ==========
    
    /**
     * @brief BFV rescale operation
     * @param ct Ciphertext with scale Δ²
     * @return Ciphertext with scale Δ (approximately ct / Δ)
     * @note This is the key BFV operation that makes noise scale-invariant
     */
    Ciphertext rescale(const Ciphertext& ct);
    
    // ========== Relinearization ==========
    
    /**
     * @brief Relinearize ciphertext from 3 to 2 components
     * @param ct Ciphertext with 3 components (after multiply)
     * @param rk Relinearization key
     * @return Ciphertext with 2 components
     */
    Ciphertext relinearize(const Ciphertext& ct, const RelinKey& rk);
    
    /**
     * @brief Multiply, relinearize, and rescale in one operation
     * @param ct1 First ciphertext
     * @param ct2 Second ciphertext
     * @param rk Relinearization key
     * @return rescale(relinearize(ct1 * ct2))
     */
    Ciphertext multiply_relin(const Ciphertext& ct1, const Ciphertext& ct2,
                               const RelinKey& rk);
    
    // ========== Noise Management ==========
    
    /**
     * @brief Estimate remaining noise budget
     * @param ct Ciphertext to analyze
     * @return Estimated noise budget in bits
     */
    double noise_budget(const Ciphertext& ct) const;
    
private:
    const BFVContext& ctx_;
    std::unique_ptr<bgv::BGVEvaluator> bgv_eval_;
};

}  // namespace kctsb::fhe::bfv

#endif  // KCTSB_ADVANCED_FE_BFV_BFV_HPP
